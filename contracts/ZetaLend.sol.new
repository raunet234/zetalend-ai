// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@zetachain/protocol-contracts/contracts/zevm/SystemContract.sol";
import "@zetachain/protocol-contracts/contracts/zevm/interfaces/zContract.sol";
import "@zetachain/protocol-contracts/contracts/zevm/interfaces/IZRC20.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./interfaces/IERC20.sol";

contract ZetaLend is zContract, Pausable, Ownable {
    SystemContract public immutable systemContract;
    uint256 public constant MAX_LTV = 75; // 75% max LTV ratio
    uint256 public constant LIQUIDATION_THRESHOLD = 80; // 80% liquidation threshold

    struct Loan {
        uint256 collateralAmount;
        uint256 borrowedAmount;
        address collateralToken;
        address borrowedToken;
        uint256 timestamp;
        bool active;
    }

    mapping(address => Loan[]) public loans;
    mapping(address => bool) public supportedTokens;
    
    event Deposit(address indexed user, address token, uint256 amount);
    event Borrow(address indexed user, address token, uint256 amount);
    event Repay(address indexed user, address token, uint256 amount);
    event Withdraw(address indexed user, address token, uint256 amount);
    event TokenAdded(address token);
    event TokenRemoved(address token);

    constructor(address systemContractAddress) {
        systemContract = SystemContract(systemContractAddress);
        // Add ETH (represented as address(0) in our system) as supported token
        supportedTokens[address(0)] = true;
    }

    // Add a direct deposit function for ETH
    function deposit() external payable whenNotPaused {
        require(msg.value > 0, "ZetaLend: deposit amount must be greater than 0");
        
        Loan memory newLoan = Loan({
            collateralAmount: msg.value,
            borrowedAmount: 0,
            collateralToken: address(0), // Using address(0) to represent native ETH
            borrowedToken: address(0),
            timestamp: block.timestamp,
            active: true
        });
        
        loans[msg.sender].push(newLoan);
        emit Deposit(msg.sender, address(0), msg.value);
    }

    function onCrossChainCall(
        zContext calldata context,
        address zrc20,
        uint256 amount,
        bytes calldata message
    ) external virtual override whenNotPaused {
        require(msg.sender == address(systemContract), "ZetaLend: only system contract");
        
        // Decode message to determine action (deposit/borrow)
        (bytes1 action, address recipient) = abi.decode(message, (bytes1, address));
        
        if (action == 0x01) { // Deposit
            address userAddress = address(uint160(uint256(bytes32(context.origin))));
            _handleDeposit(userAddress, zrc20, amount);
        } else if (action == 0x02) { // Borrow
            _handleBorrow(recipient, zrc20, amount);
        }
    }

    function _handleDeposit(address user, address token, uint256 amount) internal {
        require(supportedTokens[token], "ZetaLend: token not supported");
        
        Loan memory newLoan = Loan({
            collateralAmount: amount,
            borrowedAmount: 0,
            collateralToken: token,
            borrowedToken: address(0),
            timestamp: block.timestamp,
            active: true
        });
        
        loans[user].push(newLoan);
        emit Deposit(user, token, amount);
    }

    function _handleBorrow(address recipient, address token, uint256 amount) internal {
        require(supportedTokens[token], "ZetaLend: token not supported");
        require(loans[recipient].length > 0, "ZetaLend: no collateral deposited");
        
        Loan storage loan = loans[recipient][loans[recipient].length - 1];
        require(loan.active && loan.borrowedAmount == 0, "ZetaLend: invalid loan state");
        
        // Simple 1:1 ratio check (should use oracle in production)
        uint256 maxBorrow = (loan.collateralAmount * MAX_LTV) / 100;
        require(amount <= maxBorrow, "ZetaLend: exceeds max LTV");
        
        require(IERC20(token).transfer(recipient, amount), "ZetaLend: transfer failed");
        
        loan.borrowedAmount = amount;
        loan.borrowedToken = token;
        
        emit Borrow(recipient, token, amount);
    }

    function calculateLTV(Loan memory loan) public pure returns (uint256) {
        if (loan.collateralAmount == 0) return 0;
        return (loan.borrowedAmount * 100) / loan.collateralAmount;
    }

    function addSupportedToken(address token) external onlyOwner {
        supportedTokens[token] = true;
        emit TokenAdded(token);
    }

    function removeSupportedToken(address token) external onlyOwner {
        supportedTokens[token] = false;
        emit TokenRemoved(token);
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function repayLoan(uint256 loanIndex) external whenNotPaused {
        require(loanIndex < loans[msg.sender].length, "ZetaLend: invalid loan index");
        Loan storage loan = loans[msg.sender][loanIndex];
        require(loan.active && loan.borrowedAmount > 0, "ZetaLend: no active loan");
        
        uint256 repayAmount = loan.borrowedAmount;
        require(IERC20(loan.borrowedToken).transferFrom(msg.sender, address(this), repayAmount), 
                "ZetaLend: repayment failed");
        
        loan.borrowedAmount = 0;
        emit Repay(msg.sender, loan.borrowedToken, repayAmount);
    }
    
    function withdrawCollateral(uint256 loanIndex) external whenNotPaused {
        require(loanIndex < loans[msg.sender].length, "ZetaLend: invalid loan index");
        Loan storage loan = loans[msg.sender][loanIndex];
        require(loan.active && loan.borrowedAmount == 0, "ZetaLend: loan not repaid");
        
        uint256 collateralAmount = loan.collateralAmount;
        loan.active = false;
        loan.collateralAmount = 0;
        
        if (loan.collateralToken == address(0)) {
            // Native ETH withdrawal
            (bool success, ) = msg.sender.call{value: collateralAmount}("");
            require(success, "ZetaLend: ETH withdrawal failed");
        } else {
            // Token withdrawal
            require(IERC20(loan.collateralToken).transfer(msg.sender, collateralAmount), 
                    "ZetaLend: withdrawal failed");
        }
        
        emit Withdraw(msg.sender, loan.collateralToken, collateralAmount);
    }

    function getUserLoans(address user) external view returns (Loan[] memory) {
        return loans[user];
    }

    // Emergency withdrawal function
    function emergencyWithdraw(address token) external onlyOwner {
        uint256 balance = IERC20(token).balanceOf(address(this));
        require(IERC20(token).transfer(owner(), balance), "ZetaLend: transfer failed");
    }
    
    // Emergency ETH withdrawal
    function emergencyWithdrawETH() external onlyOwner {
        uint256 balance = address(this).balance;
        (bool success, ) = owner().call{value: balance}("");
        require(success, "ZetaLend: ETH withdrawal failed");
    }
    
    // Required to receive ETH
    receive() external payable {}
}
